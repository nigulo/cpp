// Class automatically generated by Dev-C++ New Class wizard

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "texture.h" // class's header file

using namespace engine3d;

// class constructor
Texture::Texture(const String& textureFile, const String& name) : Object(name)
{

    std::vector<unsigned char> image;
    unsigned width, height;
	unsigned error = lodepng::decode(image, width, height, textureFile.GetChars());
	if (error != 0) {
		throw (String("Loading texture ") + textureFile + " failed: " + String((int) error) + ", " + lodepng_error_text(error));
	} else {
		Debug(String("Texture ") + textureFile + " loaded");
	}

	// Texture size must be power of two for the primitive OpenGL version this is written for. Find next power of two.
	mWidth = 1;
	while (mWidth < width) {
		mWidth *= 2;
	};
	mHeight = 1;
	while (mHeight < height) {
		mHeight *= 2;
	}

	mpImage = new std::vector<unsigned char>(mWidth * mHeight * 4);
	// Make power of two version of the image.
	std::vector<unsigned char> image2(mWidth * mHeight * 4);
	for(size_t y = 0; y < height; y++) {
		for(size_t x = 0; x < width; x++) {
			for(size_t c = 0; c < 4; c++) {
				(*mpImage)[4 * mWidth * y + 4 * x + c] = image[4 * width * y + 4 * x + c];
			}
		}
	}

}

// private constructor
// class destructor
Texture::~Texture()
{
	if (mpImage) {
		delete mpImage;
	}
}

/**
 * Modulates this texture with another texture.
 * RGBA texture can be constructed from
 * RGB texture by modulating it with ALPHA texture
 **/
/*
Texture& Texture::Modulate(const Texture& texture)
{
    assert(mWidth == texture.mWidth && mHeight == texture.mHeight);
    assert(texture.mFormat == FORMAT_ALPHA && (mFormat == FORMAT_RGB || mFormat == FORMAT_RGB));
    if (mFormat == FORMAT_RGB && texture.mFormat == FORMAT_ALPHA){
    	GLvoid* p_pixels = new GLvoid[mWidth * mHeight * 4];
        for (long i = 0; i < mWidth * mHeight; i++) {
            p_pixels[i * 4] = mpPixels[i * 3];
            p_pixels[i * 4 + 1] = mpPixels[i * 3 + 1];
            p_pixels[i * 4 + 2] = mpPixels[i * 3 + 2];
            p_pixels[i * 4 + 3] = texture.mpPixels[i];
        }
        delete[] mpPixels;
        mpPixels = p_pixels;
        mFormat = FORMAT_RGBA;
        //return new Texture(mWidth, mHeight, FORMAT_RGBA, p_pixels);
    }
    else if (mFormat == FORMAT_LUMINANCE && texture.mFormat == FORMAT_ALPHA) {
    	GLvoid* p_pixels = new GLvoid[mWidth * mHeight * 2];
        for (long  i = 0; i < mWidth * mHeight; i++) {
            p_pixels[i<<1] = mpPixels[i];
            p_pixels[i<<1 + 1] = texture.mpPixels[i];
        }
        delete[] mpPixels;
        mpPixels = p_pixels;
        //return new Texture(mWidth, mHeight, FORMAT_LUMINANCE_ALPHA, p_pixels);
    }
    // Other formats are not supported
    return *this;
}
*/
