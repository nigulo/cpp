// Class automatically generated by Dev-C++ New Class wizard

#include <gl.h>
#include <glu.h>

#include "camera.h" // class's header file
#include <math.h>

using namespace engine3d;
// class constructor
Camera::Camera(double viewAngle, double aspect, double zNear, double zFar) : Node("Camera"),
    mViewAngle(viewAngle),
    mAspect(aspect),
    mZNear(zNear),
    mZFar(zFar),
    mEye(0, 0, 0),
    mCenter(0, 0, 1),
    mUp(0, 1, 0),
    mPerspective(true)
{
    mChanged = true;
}

Camera::Camera(double left, double right, double bottom, double top, double zNear, double zFar) :
    mLeft(left),
    mRight(right),
    mBottom(bottom),
    mTop(top),
    mZNear(zNear),
    mZFar(zFar),
    mEye(0, 0, 0),
    mCenter(0, 0, 1),
    mUp(0, 1, 0),
    mPerspective(false)
{
    mChanged = true;
}

Camera::Camera(const Camera& rCam) :
    mViewAngle(rCam.mViewAngle),
    mAspect(rCam.mAspect),
    mZNear(rCam.mZNear),
    mZFar(rCam.mZFar),
    mEye(rCam.mEye),
    mCenter(rCam.mCenter),
    mUp(rCam.mUp),
    mPerspective(rCam.mPerspective),
    mLeft(rCam.mLeft),
    mRight(rCam.mRight),
    mBottom(rCam.mBottom),
    mTop(rCam.mTop),
    Node(rCam)
{
    mChanged = true;
}

// class destructor
Camera::~Camera()
{
}

void engine3d::Camera::Init() {
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
	if (mPerspective) {
		gluPerspective(mViewAngle, mAspect, mZNear, mZFar);
	} else {
	    glOrtho(mLeft, mRight, mBottom, mTop, mZNear, mZFar);
	}
    glMatrixMode(GL_MODELVIEW);
    mChanged = true;
	Node::Init();
}

void Camera::Look()
{
	//if (mPerspective) {
	    //Vector eye = mTransformation.Transform(mEye);
	    //Vector center = mTransformation.Transform(mCenter);
	    //Vector up = mTransformation.Transform(mUp);
	    Debug(String("Camera::Look eye ") + mEye.ToString());
	    Debug(String("Camera::Look center ") + mCenter.ToString());
	    Debug(String("Camera::Look up ") + mUp.ToString());
	    gluLookAt(mEye[0], mEye[1], mEye[2],
	              mCenter[0], mCenter[1], mCenter[2],
	              mUp[0], mUp[1], mUp[2]);
	//}
    mChanged = false;
}

/**
 * The normal of the returned plane is pointing inside
 * the viewing frustrum
 * Not precise!
 **/
const Plane Camera::GetFarPlane() const 
{
    //assert(center);
    //assert(eye);
	Vector plane_normal = GetDirection();
	//Vector planePoint = eye + (planeNormal * zFar);
	// NB! This is not correct. just added to avoid 
    // distantprojections rounded behind farplane
	Vector plane_point = mEye + (plane_normal * mZFar * 0.99);
	return Plane(plane_point, plane_normal * (-1));
}

/**
 * The normal of the returned plane is pointing inside
 * the viewing frustrum
 * WARNING: NOT TESTED!!!
 **/
const Plane Camera::GetNearPlane() const 
{
    //assert(center);
    //assert(eye);
	Vector plane_normal = GetDirection();
	Vector plane_point = mEye + (plane_normal * mZNear);
	return Plane(plane_point, plane_normal);
}

/**
 * The normal of the returned plane is pointing inside
 * the viewing frustrum
 * WARNING: NOT TESTED!!!
 **/
const Plane Camera::GetTopPlane() const 
{
	if (mPerspective) {
	    //assert(center);
	    //assert(eye);
		Vector direction = GetDirection();
		Vector down = (-mUp) * tan((M_PI * mViewAngle / 360));
		Vector plane_normal = (direction + down) * 0.5;
		Vector plane_point = mEye;
		return Plane(plane_point, plane_normal);
	} 
	else {
		return Plane(mEye + mUp * mTop, -mUp);
	}
}

/**
 * The normal of the returned plane is pointing inside
 * the viewing frustrum
 * WARNING: NOT TESTED!!!
 **/
const Plane Camera::GetBottomPlane() const 
{
	if (mPerspective) {
	    //assert(center);
	    //assert(eye);
		Vector direction = GetDirection();
		Vector plane_normal = (direction + mUp * tan((M_PI * mViewAngle / 360))) * 0.5;
		Vector plane_point = mEye;
		return Plane(plane_point, plane_normal);
	} 
	else {
		return Plane(mEye + (-mUp) * mBottom, mUp);
	}
}

/**
 * The normal of the returned plane is pointing inside
 * the viewing frustrum
 * WARNING: NOT TESTED!!!
 **/
const Plane Camera::GetLeftPlane() const 
{
	if (mPerspective) {
	    //assert(center);
	    //assert(eye);
		Vector direction = GetDirection();
		Vector right = direction.CrossProduct(mUp);
		Vector plane_normal = (direction + right * tan((M_PI * mViewAngle * mAspect / 360))) * 0.5;
		Vector plane_point = mEye;
		return Plane(plane_point, plane_normal);
	}
	else {
		Vector right = GetDirection().CrossProduct(mUp);
		return Plane(mEye + (-right) * mLeft, right);
	}
}

/**
 * The normal of the returned plane is pointing inside
 * the viewing frustrum
 * WARNING: NOT TESTED!!!
 **/
const Plane Camera::GetRightPlane() const 
{
	if (mPerspective) {
	    //assert(center);
	    //assert(eye);
		Vector direction = GetDirection();
		Vector left = mUp.CrossProduct(direction);
		Vector plane_normal = (direction + left * tan((M_PI * mViewAngle * mAspect / 360))) * 0.5;
		Vector plane_point = mEye;
		return Plane(plane_point, plane_normal);
	}
	else {
		Vector left = mUp.CrossProduct(GetDirection());
		return Plane(mEye + (-left) * mRight, left);
	}
}

/**
 * Sets the camera's world transformation. Transformation
 * defines the location and direction of the camera.
 * @param rTransformation new transformation of the camera. 
 **/
//void Camera::SetTransformation(const Transformation& rTransformation) {
//    // Re-calculate eye, center and up vectors and 
//    // set changed to true
//
//    if (!CheckCollisions(rTransformation)) {
//        Vector mEye = rTransformation.Transform(Vector(0, 0, 0));
//        Vector mCenter = rTransformation.Transform(Vector(0, 0, 1));
//        Vector mUp = (rTransformation.Rotate(Vector(0, 1, 0))).Normalize();
//        mTransformation = rTransformation;
//        mWorldTransformation = rTransformation;
//    }
//}

/**
 * Checks if the given volume is out of the camera's view.
 * @rVolume bounding volume to check for culling
 * @return ture if the given volume can be culled, false otherwise
 **/
bool Camera::Cull(const BoundingVolume& rVolume)
{
    return false; // Culling may not work correctly with ortographic projection
    if (rVolume.WhichSide(GetLeftPlane()) == Plane::PLACEMENT_BACK) {
        Debug("Cull 2");
        return true;
    }
    else if (rVolume.WhichSide(GetRightPlane()) == Plane::PLACEMENT_BACK) {
        Debug("Cull 3");
        return true;
    }
    else if (rVolume.WhichSide(GetTopPlane()) == Plane::PLACEMENT_BACK) {
        Debug("Cull 4");
        return true;
    }
    else if (rVolume.WhichSide(GetBottomPlane()) == Plane::PLACEMENT_BACK) {
        Debug("Cull 5");
        return true;
    }
    else if (rVolume.WhichSide(GetNearPlane()) == Plane::PLACEMENT_BACK) {
        Debug("Cull 6");
        return true;
    }
    else if (rVolume.WhichSide(GetFarPlane()) == Plane::PLACEMENT_BACK) {
        Debug("Cull 7");
        return true;
    }
    return false;
}

void Camera::Transform()
{
    Spatial::Transform();
    // Re-calculate eye, center and up vectors
    mEye = mTransformation.Transform(Vector(0, 0, 0));
    mCenter = mTransformation.Transform(Vector(0, 0, 1));
    mUp = (mTransformation.Rotate(Vector(0, 1, 0))).Normalize();
}
