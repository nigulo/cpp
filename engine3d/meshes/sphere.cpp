// Class automatically generated by Dev-C++ New Class wizard

#include <math.h>

#include "sphere.h" // class's header file
#include "engine3d/scenegraph/camera.h" // class's header file
#include "engine3d/scenegraph/scene.h"

using namespace engine3d;

// class constructor
Sphere::Sphere(double radius, int parts1, int parts2, bool genTexCoords, double completeness) :
    rings(parts1 - 2)
{
    assert(radius >= 0);
    assert(parts1 >= 10);
    assert(parts2 >= 10);
    assert(completeness >= 0 && completeness <= 1);
    top = new Triangles();
    bottom = new Triangles();
	this->radius = radius;
	this->parts1 = parts1;
	this->parts2 = parts2;
	this->completeness = completeness;
	
    double dTheta = M_PI / parts1;
    double theta = dTheta;
    double dPhi = 2.0f * M_PI / parts2;
    double phi = 0.0f;
    double ds = 1.0f / parts2;
    double dt = 1.0f / parts1;
    double s = 0.0f;
    double t = 1.0f - dt / 2.0f;

    // Create top
    double y = radius * cos(theta);
    double r = sqrt(radius * radius - y * y);
	for (int i = 0; i < parts2; i++) {
        double z1 = r * cos(phi);
        double x1 = r * sin(phi);
        double z2 = r * cos(phi + dPhi);
        double x2 = r * sin(phi + dPhi);
        if (i == 0) {
            z1 = r;
            x1 = 0.0f;
        }
        else if (i == parts2 - 1) {
            z2 = r;
            x2 = 0.0f;
        }
        Vertex v1(0, radius, 0);
	    if (genTexCoords) {
            v1.SetTexCoords(Vector(s + ds / 2, 1));
        }
        Vertex v2(x1, y, z1);
	    if (genTexCoords) {
            v2.SetTexCoords(Vector(s, t));
        }

        Vertex v3(x2, y, z2);
	    if (genTexCoords) {
            v3.SetTexCoords(Vector(s + ds, t));
        }
        top->Add(v1, v2, v3);
        phi += dPhi;
        s += ds;
    }
    
	double yStop = radius - (2 * radius * completeness); 
    // Create middle rings
    for (int i = 0; i < parts1 - 2 && y >= yStop; i++) {
        TriangleStrip* ring = new TriangleStrip();
        double r1 = sqrt(radius * radius - y * y);
        double y2 = radius * cos(theta + dTheta);
        double r2 = sqrt(radius * radius - y2 * y2);
        phi = 0;
        s = 0;
        for (int j = 0; j < parts2 + 1; j++) {
            double cosPhi = cos(phi);
            double sinPhi = sin(phi);
            double z1 = r1 * cosPhi;
            double x1 = r1 * sinPhi;
            double z2 = r2 * cosPhi;
            double x2 = r2 * sinPhi;
            if (j == 0) {
                z1 = r1;
                x1 = 0.0f;
            }
            else if (j == parts2) {
                z2 = r2;
                x2 = 0.0f;
            }
            Vertex v1(x1, y, z1);
            if (genTexCoords) {
                v1.SetTexCoords(Vector(s, t));
            }
            ring->AddVertex(v1);
            Vertex v2(x2, y2, z2);
            if (genTexCoords) {
                v2.SetTexCoords(Vector(s, t - dt));
            }
            ring->AddVertex(v2);
            phi += dPhi;
            s += ds;
        }
        rings.Add(ring);
        theta += dTheta;
        y = radius * cos(theta);
        t -= dt;
    }
	
    if (y >= yStop) {
	    // Create bottom
	    phi = 0.0f;
	    s = 1.0f;
	    t = dt / 2.0f;
	    r = sqrt(radius * radius - y * y);
		for (int i = 0; i < parts1; i++) {
	        double z1 = r * cos(phi);
	        double x1 = r * sin(phi);
	        double z2 = r * cos(phi - dPhi);
	        double x2 = r * sin(phi - dPhi);
	        if (i == 0) {
	            z1 = r;
	            x1 = 0.0f;
	        }
	        else if (i == parts1 - 1) {
	            z2 = r;
	            x2 = 0.0f;
	        }
	        Vertex v1(0, -radius, 0);
		    if (genTexCoords) {
	            v1.SetTexCoords(Vector(s - ds / 2, 0));
	        }
	        Vertex v2(x1, y, z1);
		    if (genTexCoords) {
	            v2.SetTexCoords(Vector(s, t));
	        }
	
	        Vertex v3(x2, y, z2);
		    if (genTexCoords) {
	            v3.SetTexCoords(Vector(s - ds, t));
	        }
	        bottom->Add(v1, v2, v3);
	        phi -= dPhi;
	        s -= ds;
	    }
    }
	//-------------------------------------------
	// Attach the sphere parts to the sphere node
	//AddChild(&top);
    //for (int i = 0; i < rings.size(); i++) {
    //    AddChild(rings[i]);
    //}
    //AddChild(&bottom);
}

void Sphere::Copy(const Sphere& sphere)
{
    Shape::Copy(sphere);
	this->radius = sphere.radius;
	this->parts1 = sphere.parts1;
	this->parts2 = sphere.parts2;
	this->completeness = sphere.completeness;
	this->top = sphere.top->Clone();
    for (int i = 0; i < sphere.rings.Size(); i++) {
        rings.Add(sphere.rings[i]->Clone());
    }
	this->bottom = sphere.bottom->Clone();
}

Sphere* Sphere::Clone() const
{
    Debug("Sphere.Clone");
    Sphere* p_sphere = new Sphere(radius, parts1, parts2);
    p_sphere->Copy(*this);
    return p_sphere;
}

// class destructor
Sphere::~Sphere()
{
    delete top;
	for (int i = 0; i < rings.Size(); i++) {
        delete rings[i];
    }
    rings.Clear();
    delete bottom;
}

void Sphere::Render() 
{
    Debug("Sphere::Draw");
    const Color* p_color = GetColor();
    RemoveColor();
    Shape::Render();
    if (p_color) {
    	top->SetColor(*p_color);
    }
    top->Render();
    for (int i = 0; i < rings.Size(); i++) {
        if (p_color) {
        	rings[i]->SetColor(*p_color);
        }
        rings[i]->Render();
    }
    if (p_color) {
    	bottom->SetColor(*p_color);
    }
    bottom->Render();
    if (p_color) {
    	SetColor(*p_color);
    }
}

//void Sphere::SetDistant()
//{
//	Node::SetDistant(true);
//	top.SetDistant(true);
//    for (int i = 0; i < rings.size(); i++) {
//        rings[i]->SetDistant(true);
//    }
//	bottom.SetDistant(true);
//}

void Sphere::Init() 
{
	Shape::Init();
	Camera& r_cam = GetScene().GetCamera();
	Vector o = mWorldTransformation.Transform(Vector(0, 0, 0));
	if ((o - r_cam.GetEye()).DotProduct((r_cam.GetCenter() - r_cam.GetEye()).Normalize()) > r_cam.GetZFar()) {
		Debug("distant");
		//SetDistant(true);
	}
	else {
		Debug("not distant");
		//SetDistant(false);
	}
}
