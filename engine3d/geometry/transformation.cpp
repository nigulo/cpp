// Class automatically generated by Dev-C++ New Class wizard

#include <gl.h>
#include <math.h>

#include "transformation.h" // class's header file

using namespace engine3d;

// class constructor
Transformation::Transformation() : mMatrix(Matrix::GetUnit(4))
{
    //matrix = new Matrix(Matrix::GetUnit(4));
}

Transformation::Transformation(const Matrix& m) : mMatrix(m)
{
    //matrix = new Matrix(m);
}

// class constructor
Transformation::Transformation(const Transformation& t) : mMatrix(t.mMatrix)
{
//    matrix = NULL;
//    if (t.matrix) {
//        matrix = new Matrix(*t.matrix);
//    }
}

Transformation::Transformation(const Vector& translation) :
    mMatrix(Matrix::GetUnit(4))
{
    //matrix = new Matrix(Matrix::GetUnit(4));
    SetTranslation(translation);
}

Transformation::Transformation(const Vector& rotAxis, double rotAngle) :
    mMatrix(Matrix::GetUnit(4))
{
    //matrix = new Matrix(Matrix::GetUnit(4));
    SetRotation(rotAxis, rotAngle);
}

Transformation::Transformation(const Vector& rotAxis, double rotAngle, const Vector& translation)  :
    mMatrix(Matrix::GetUnit(4))
{
    //matrix = new Matrix(Matrix::GetUnit(4));
    SetRotation(rotAxis, rotAngle);
    SetTranslation(translation);
}

Transformation& Transformation::operator=(const Transformation& t) 
{
    if (this != &t) {
        mMatrix = t.mMatrix;
//        matrix = NULL;
//        if (t.matrix) {
//            matrix = new Matrix(*t.matrix);
//        }
    }
    return *this;
}

// class destructor
Transformation::~Transformation()
{
//    if (matrix) {
//        delete matrix;
//    }
}

// Rotates around the given axes
void Transformation::SetRotation(const Vector& axis, double angle)
{
    Vector a(axis);
    a.Normalize();
    Matrix s;
    Vector v1(0, -a[2], a[1]);
    Vector v2(a[2], 0, -a[0]);
    Vector v3(-a[1], a[0], 0);
    s.SetRow(0, v1);
    s.SetRow(1, v2);
    s.SetRow(2, v3);
    Matrix rotation(Matrix::GetUnit() + s * sin(angle) +  s * s * (1 - cos(angle)));
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            //matrix->Set(i, j, rotation.Get(i, j));
            mMatrix.Set(i, j, rotation.Get(i, j));
        }
    }
}

// No description
void Transformation::SetTranslation(const Vector& shift)
{
//    matrix->Set(3, 0, shift[0]);
//    matrix->Set(3, 1, shift[1]);
//    matrix->Set(3, 2, shift[2]);
    mMatrix.Set(3, 0, shift[0]);
    mMatrix.Set(3, 1, shift[1]);
    mMatrix.Set(3, 2, shift[2]);
}

void Transformation::SetMatrix(const Matrix& m) {
//    if (matrix) {
//        delete matrix;
//    }
//    matrix = new Matrix(m);
    mMatrix = m;
}

const Matrix& Transformation::GetMatrix() const {
    //return *matrix;
    return mMatrix;
}

/**
 * Performs the OpenGL transformation
 **/
void Transformation::Transform()
{
    
    //const double* trMatrix = matrix->GetElements();
    const double* trMatrix = mMatrix.GetElements();
    glMultMatrixd(trMatrix);
}

Transformation Transformation::operator*(const Transformation& t) const
{
    //return Transformation((*matrix) * (*t.matrix));
    return Transformation(mMatrix * t.mMatrix);
}

Vector Transformation::Transform(const Vector& v) const
{
    //assert(matrix);
    assert(v.GetDim() == 3);
    Vector v1(v[0], v[1], v[2], 1);
    //Vector v2 = (*matrix) * v1;
    Vector v2 = mMatrix * v1;
    return Vector(v2[0], v2[1], v2[2]);
}

Vector Transformation::Rotate(const Vector& v) const
{
    //assert(matrix);
    assert(v.GetDim() == 3);
    Vector v1(v[0], v[1], v[2], 1);
    Matrix m = Matrix::GetUnit(4);
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            //m.Set(i, j, matrix->Get(i, j));
            m.Set(i, j, mMatrix.Get(i, j));
        }
    }
    Vector v2 = m * v1;
    return Vector(v2[0], v2[1], v2[2]);
}

Vector Transformation::Translate(const Vector& v) const
{
    //assert(matrix);
    assert(v.GetDim() == 3);
    Vector v1(v[0], v[1], v[2], 1);
    Matrix m = Matrix::GetUnit(4);
    //m.Set(3, 0, matrix->Get(3, 0));
    //m.Set(3, 1, matrix->Get(3, 1));
    //m.Set(3, 2, matrix->Get(3, 2));
    m.Set(3, 0, mMatrix.Get(3, 0));
    m.Set(3, 1, mMatrix.Get(3, 1));
    m.Set(3, 2, mMatrix.Get(3, 2));
    Vector v2 = m * v1;
    return Vector(v2[0], v2[1], v2[2]);
}

Transformation Transformation::GetTranslation() const
{
    Matrix m = Matrix::GetUnit(4);
    //m.Set(3, 0, matrix->Get(3, 0));
    //m.Set(3, 1, matrix->Get(3, 1));
    //m.Set(3, 2, matrix->Get(3, 2));
    m.Set(3, 0, mMatrix.Get(3, 0));
    m.Set(3, 1, mMatrix.Get(3, 1));
    m.Set(3, 2, mMatrix.Get(3, 2));
    return Transformation(m);
}

Transformation Transformation::GetRotation() const
{
    Matrix m = Matrix::GetUnit(4);
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            //m.Set(i, j, matrix->Get(i, j));
            m.Set(i, j, mMatrix.Get(i, j));
        }
    }
    return Transformation(m);
}
